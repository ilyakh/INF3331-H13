


	union() {
		translate(v = [0, 100.0000000000, 0.0000000000]) {
			rotate(a = 0.0000000000, v = [1, 0, 0]) {
				cylinder(h = 20.0000000000, r = 36.1920641476, center = true);
			}
		}
		translate(v = [0, 98.4807753012, 17.3648177667]) {
			rotate(a = 10.0000000000, v = [1, 0, 0]) {
				cylinder(h = 20.0000000000, r = 35.7253536863, center = true);
			}
		}
		translate(v = [0, 93.9692620786, 34.2020143326]) {
			rotate(a = 20.0000000000, v = [1, 0, 0]) {
				cylinder(h = 20.0000000000, r = 35.5201688182, center = true);
			}
		}
		translate(v = [0, 86.6025403784, 50.0000000000]) {
			rotate(a = 30.0000000000, v = [1, 0, 0]) {
				cylinder(h = 20.0000000000, r = 37.4162145060, center = true);
			}
		}
		translate(v = [0, 76.6044443119, 64.2787609687]) {
			rotate(a = 40.0000000000, v = [1, 0, 0]) {
				cylinder(h = 20.0000000000, r = 38.8870476259, center = true);
			}
		}
		translate(v = [0, 64.2787609687, 76.6044443119]) {
			rotate(a = 50.0000000000, v = [1, 0, 0]) {
				cylinder(h = 20.0000000000, r = 36.9545337678, center = true);
			}
		}
		translate(v = [0, 50.0000000000, 86.6025403784]) {
			rotate(a = 60.0000000000, v = [1, 0, 0]) {
				cylinder(h = 20.0000000000, r = 34.4345086035, center = true);
			}
		}
		translate(v = [0, 34.2020143326, 93.9692620786]) {
			rotate(a = 70.0000000000, v = [1, 0, 0]) {
				cylinder(h = 20.0000000000, r = 33.9714066240, center = true);
			}
		}
		translate(v = [0, 17.3648177667, 98.4807753012]) {
			rotate(a = 80.0000000000, v = [1, 0, 0]) {
				cylinder(h = 20.0000000000, r = 40.3246534410, center = true);
			}
		}
		translate(v = [0, 0.0000000000, 100.0000000000]) {
			rotate(a = 90.0000000000, v = [1, 0, 0]) {
				cylinder(h = 20.0000000000, r = 45.5074733250, center = true);
			}
		}
		translate(v = [0, -17.3648177667, 98.4807753012]) {
			rotate(a = 100.0000000000, v = [1, 0, 0]) {
				cylinder(h = 20.0000000000, r = 39.9956720441, center = true);
			}
		}
		translate(v = [0, -34.2020143326, 93.9692620786]) {
			rotate(a = 110.0000000000, v = [1, 0, 0]) {
				cylinder(h = 20.0000000000, r = 31.6484756799, center = true);
			}
		}
		translate(v = [0, -50.0000000000, 86.6025403784]) {
			rotate(a = 120.0000000000, v = [1, 0, 0]) {
				cylinder(h = 20.0000000000, r = 33.6421713813, center = true);
			}
		}
		translate(v = [0, -64.2787609687, 76.6044443119]) {
			rotate(a = 130.0000000000, v = [1, 0, 0]) {
				cylinder(h = 20.0000000000, r = 39.7654080305, center = true);
			}
		}
		translate(v = [0, -76.6044443119, 64.2787609687]) {
			rotate(a = 140.0000000000, v = [1, 0, 0]) {
				cylinder(h = 20.0000000000, r = 48.9270731261, center = true);
			}
		}
		translate(v = [0, -86.6025403784, 50.0000000000]) {
			rotate(a = 150.0000000000, v = [1, 0, 0]) {
				cylinder(h = 20.0000000000, r = 48.5905320305, center = true);
			}
		}
		translate(v = [0, -93.9692620786, 34.2020143326]) {
			rotate(a = 160.0000000000, v = [1, 0, 0]) {
				cylinder(h = 20.0000000000, r = 29.6599311026, center = true);
			}
		}
		translate(v = [0, -98.4807753012, 17.3648177667]) {
			rotate(a = 170.0000000000, v = [1, 0, 0]) {
				cylinder(h = 20.0000000000, r = 32.1156669590, center = true);
			}
		}
		translate(v = [0, -100.0000000000, 0.0000000000]) {
			rotate(a = 180.0000000000, v = [1, 0, 0]) {
				cylinder(h = 20.0000000000, r = 48.7682396616, center = true);
			}
		}
		translate(v = [0, -98.4807753012, -17.3648177667]) {
			rotate(a = 190.0000000000, v = [1, 0, 0]) {
				cylinder(h = 20.0000000000, r = 42.6114111133, center = true);
			}
		}
		translate(v = [0, -93.9692620786, -34.2020143326]) {
			rotate(a = 200.0000000000, v = [1, 0, 0]) {
				cylinder(h = 20.0000000000, r = 28.2828804679, center = true);
			}
		}
		translate(v = [0, -86.6025403784, -50.0000000000]) {
			rotate(a = 210.0000000000, v = [1, 0, 0]) {
				cylinder(h = 20.0000000000, r = 48.7238349953, center = true);
			}
		}
		translate(v = [0, -76.6044443119, -64.2787609687]) {
			rotate(a = 220.0000000000, v = [1, 0, 0]) {
				cylinder(h = 20.0000000000, r = 45.8909892640, center = true);
			}
		}
		translate(v = [0, -64.2787609687, -76.6044443119]) {
			rotate(a = 230.0000000000, v = [1, 0, 0]) {
				cylinder(h = 20.0000000000, r = 29.2496733080, center = true);
			}
		}
		translate(v = [0, -50.0000000000, -86.6025403784]) {
			rotate(a = 240.0000000000, v = [1, 0, 0]) {
				cylinder(h = 20.0000000000, r = 49.6505316933, center = true);
			}
		}
		translate(v = [0, -34.2020143326, -93.9692620786]) {
			rotate(a = 250.0000000000, v = [1, 0, 0]) {
				cylinder(h = 20.0000000000, r = 29.2505642136, center = true);
			}
		}
		translate(v = [0, -17.3648177667, -98.4807753012]) {
			rotate(a = 260.0000000000, v = [1, 0, 0]) {
				cylinder(h = 20.0000000000, r = 27.2175074853, center = true);
			}
		}
		translate(v = [0, -0.0000000000, -100.0000000000]) {
			rotate(a = 270.0000000000, v = [1, 0, 0]) {
				cylinder(h = 20.0000000000, r = 49.2340026183, center = true);
			}
		}
		translate(v = [0, 17.3648177667, -98.4807753012]) {
			rotate(a = 280.0000000000, v = [1, 0, 0]) {
				cylinder(h = 20.0000000000, r = 29.2823103735, center = true);
			}
		}
		translate(v = [0, 34.2020143326, -93.9692620786]) {
			rotate(a = 290.0000000000, v = [1, 0, 0]) {
				cylinder(h = 20.0000000000, r = 38.5631158774, center = true);
			}
		}
		translate(v = [0, 50.0000000000, -86.6025403784]) {
			rotate(a = 300.0000000000, v = [1, 0, 0]) {
				cylinder(h = 20.0000000000, r = 48.8953449607, center = true);
			}
		}
		translate(v = [0, 64.2787609687, -76.6044443119]) {
			rotate(a = 310.0000000000, v = [1, 0, 0]) {
				cylinder(h = 20.0000000000, r = 36.1765099460, center = true);
			}
		}
		translate(v = [0, 76.6044443119, -64.2787609687]) {
			rotate(a = 320.0000000000, v = [1, 0, 0]) {
				cylinder(h = 20.0000000000, r = 31.7374380037, center = true);
			}
		}
		translate(v = [0, 86.6025403784, -50.0000000000]) {
			rotate(a = 330.0000000000, v = [1, 0, 0]) {
				cylinder(h = 20.0000000000, r = 32.4970516826, center = true);
			}
		}
		translate(v = [0, 93.9692620786, -34.2020143326]) {
			rotate(a = 340.0000000000, v = [1, 0, 0]) {
				cylinder(h = 20.0000000000, r = 40.4934190573, center = true);
			}
		}
		translate(v = [0, 98.4807753012, -17.3648177667]) {
			rotate(a = 350.0000000000, v = [1, 0, 0]) {
				cylinder(h = 20.0000000000, r = 39.6444306920, center = true);
			}
		}
	}

/***********************************************
******      SolidPython code:      *************
************************************************
 
# -*- coding: utf-8 -*-

from core import *
from csv import reader
from pandas.io.parsers import read_csv


def circle( self, r, n ):
    points = []

    for t in range( 0, int(2*pi) ):
        x = r * cos(t)
        y = r * sin(t)
        points.append( [x,y] )

    return points




class Representation( Element ):


    def get_circle( self, r, n ):
        points = []

        t = [ (i * ( (2*pi) / float(n) )) for i in range( 0, n ) ]

        for i in t:
            x = r * cos(i)
            y = r * sin(i)
            points.append( [x,y] )

        return points


    def create_linear( self ):
        data    =   self.p.get( 'values' )
        n       =   self.p.get( 'number_of_segments' )
        height  =   self.p.get( 'segment_height' )
        base_radius = self.p.get('base_radius')

        # calculate step
        if len(data) > n:
            step = int( len(data) / float(n) )
        else:
            step = 1

        filtered_data = data[::step]

        current_height = 0.0

        segments = []

        for v in filtered_data:
            segments.append(
                up(current_height) (
                    cylinder(
                        h=height,
                        r=((1.0 + v) * base_radius ),
                        center=True
                    )
                )
            )

            current_height += height


        return union() ( *segments )


    def create(self):
        data    =   self.p.get( 'values' )
        n       =   self.p.get( 'number_of_segments' )
        height  =   self.p.get( 'segment_height' )
        base_radius = self.p.get('base_radius')

        tick = 360.0 / n


        # calculate step
        if len(data) > n:
            step = int( len(data) / float(n) )
        else:
            step = 1

        filtered_data = data[::step]

        current_height = 0.0
        current_angle = 0.0

        segments = []

        positions = self.get_circle(
            self.p.get('circle_radius'), n
        )

        for (v, pos) in zip( filtered_data, positions ):
            segments.append(
                translate([ 0, pos[0], pos[1] ]) (
                    rotate( current_angle, [1, 0, 0] ) (
                        cylinder(
                            h=height,
                            r=( (1.0 + v) * base_radius ),
                            center=True
                        )
                    )
                )
            )

            current_height += height
            current_angle += tick


        return union() ( *segments )




if __name__ == "__main__":

    sys.setrecursionlimit( 12000 )

    with open( 'data.txt', 'rb' ) as source:
        data = read_csv(
            source,
            header=None,
            names=[
                'clock',
                'millis',
                'accel_x', 'accel_y', 'accel_z',
                'gyro_x', 'gyro_y', 'gyro_z',
                'magn_x', 'magn_y', 'magn_z' ]
        )

    acceleration = data[['accel_x', 'accel_y', 'accel_z']].copy()


    acceleration = acceleration[1250:3250]

    # calculates total acceleration from three axes
    total_acceleration = []
    for (x,y,z) in acceleration.values:
        total_acceleration.append(
            sqrt( pow(x,2) + pow(y,2) + pow(z,2) )
        )



    # find the working range for the total acceleration set

    interval = (
        min( total_acceleration ),
        max( total_acceleration )
    )

    data_range = interval[1] - interval[0]

    # print the range of values
    print "Data interval:", interval
    print "Range:", data_range

    # scale the data to the range
    scaled_total_acceleration = [
        (float(a) / data_range) for a in total_acceleration
    ]


    from pandas import DataFrame
    import matplotlib.pyplot as plt

    """
    p = DataFrame( scaled_total_acceleration )
    p.plot()
    plt.show()
    """


    e = Representation(
        Size(1,1,1),
        parameters={
            "number_of_segments": 36,
            "base_radius": 25.0,
            "values": scaled_total_acceleration,
            "segment_height": 20.0,
            "circle_radius": 100.0
        }
    )


    e.create()

    scad_render_to_file( e.put(), "project.scad" ) 
 
***********************************************/
                            
